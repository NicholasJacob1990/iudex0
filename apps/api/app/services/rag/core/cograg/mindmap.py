"""
CogGRAG Mind Map — Pure data structures for cognitive decomposition.

Based on CogGRAG (2503.06567v2): top-down decomposition of complex queries
into a hierarchical tree of sub-questions (mind map).

No I/O, no LLM calls — just data containers and tree operations.
"""

from __future__ import annotations

import uuid
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional


class NodeState(Enum):
    """State of a mind-map node during decomposition."""

    CONTINUE = "continue"  # Needs further decomposition
    END = "end"            # Leaf node — ready for retrieval


@dataclass
class MindMapNode:
    """A single node in the cognitive decomposition tree."""

    node_id: str
    question: str
    level: int
    state: NodeState = NodeState.END
    parent_id: Optional[str] = None
    children: List[str] = field(default_factory=list)

    # Filled during retrieval / reasoning (Phases 1-3)
    answer: Optional[str] = None
    evidence: List[Dict[str, Any]] = field(default_factory=list)
    verified: bool = False
    confidence: Optional[float] = None
    citations: List[str] = field(default_factory=list)

    def is_leaf(self) -> bool:
        return self.state == NodeState.END or len(self.children) == 0

    def to_dict(self) -> Dict[str, Any]:
        return {
            "node_id": self.node_id,
            "question": self.question,
            "level": self.level,
            "state": self.state.value,
            "parent_id": self.parent_id,
            "children": list(self.children),
            "answer": self.answer,
            "evidence_count": len(self.evidence),
            "verified": self.verified,
            "confidence": self.confidence,
            "citations": list(self.citations),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MindMapNode":
        return cls(
            node_id=data["node_id"],
            question=data["question"],
            level=data["level"],
            state=NodeState(data.get("state", "end")),
            parent_id=data.get("parent_id"),
            children=data.get("children", []),
            answer=data.get("answer"),
            evidence=data.get("evidence", []),
            verified=data.get("verified", False),
            confidence=data.get("confidence"),
            citations=data.get("citations", []),
        )


@dataclass
class CognitiveTree:
    """
    Hierarchical decomposition tree for a complex query.

    The root holds the original question. Children represent sub-questions
    generated by top-down decomposition (CogGRAG pattern). Leaves are
    atomic questions ready for structured retrieval.
    """

    root_question: str
    conditions: str = ""  # Extracted legal context / constraints
    nodes: Dict[str, MindMapNode] = field(default_factory=dict)
    max_depth: int = 3
    max_children: int = 4

    # Set during construction
    root_id: Optional[str] = None

    def __post_init__(self) -> None:
        if not self.nodes and self.root_question:
            root = MindMapNode(
                node_id=_make_id(),
                question=self.root_question,
                level=0,
                state=NodeState.CONTINUE,
            )
            self.root_id = root.node_id
            self.nodes[root.node_id] = root

    # ── Accessors ──────────────────────────────────────────────────────

    def root(self) -> Optional[MindMapNode]:
        if self.root_id and self.root_id in self.nodes:
            return self.nodes[self.root_id]
        return None

    def leaves(self) -> List[MindMapNode]:
        return [n for n in self.nodes.values() if n.is_leaf()]

    def nodes_by_level(self, level: int) -> List[MindMapNode]:
        return [n for n in self.nodes.values() if n.level == level]

    def max_level(self) -> int:
        if not self.nodes:
            return 0
        return max(n.level for n in self.nodes.values())

    def node_count(self) -> int:
        return len(self.nodes)

    def leaf_count(self) -> int:
        return len(self.leaves())

    # ── Mutations ──────────────────────────────────────────────────────

    def add_child(
        self,
        parent_id: str,
        question: str,
        state: NodeState = NodeState.END,
    ) -> Optional[MindMapNode]:
        """Add a child sub-question to *parent_id*. Returns the new node or None."""
        parent = self.nodes.get(parent_id)
        if parent is None:
            return None
        if parent.level + 1 >= self.max_depth:
            return None
        if len(parent.children) >= self.max_children:
            return None

        child = MindMapNode(
            node_id=_make_id(),
            question=question,
            level=parent.level + 1,
            state=state,
            parent_id=parent_id,
        )
        self.nodes[child.node_id] = child
        parent.children.append(child.node_id)
        # Parent is no longer a leaf
        parent.state = NodeState.CONTINUE
        return child

    def set_answer(
        self,
        node_id: str,
        answer: str,
        evidence: Optional[List[Dict[str, Any]]] = None,
        citations: Optional[List[str]] = None,
        confidence: Optional[float] = None,
    ) -> None:
        node = self.nodes.get(node_id)
        if node is None:
            return
        node.answer = answer
        if evidence is not None:
            node.evidence = evidence
        if citations is not None:
            node.citations = citations
        if confidence is not None:
            node.confidence = confidence

    def mark_verified(self, node_id: str, verified: bool = True) -> None:
        node = self.nodes.get(node_id)
        if node:
            node.verified = verified

    # ── Serialisation ──────────────────────────────────────────────────

    def to_dict(self) -> Dict[str, Any]:
        return {
            "root_question": self.root_question,
            "conditions": self.conditions,
            "root_id": self.root_id,
            "max_depth": self.max_depth,
            "max_children": self.max_children,
            "node_count": self.node_count(),
            "leaf_count": self.leaf_count(),
            "max_level": self.max_level(),
            "nodes": {nid: n.to_dict() for nid, n in self.nodes.items()},
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "CognitiveTree":
        tree = cls(
            root_question=data["root_question"],
            conditions=data.get("conditions", ""),
            max_depth=data.get("max_depth", 3),
            max_children=data.get("max_children", 4),
        )
        # Override auto-created root
        tree.nodes.clear()
        tree.root_id = data.get("root_id")
        for nid, ndata in data.get("nodes", {}).items():
            tree.nodes[nid] = MindMapNode.from_dict(ndata)
        return tree


# ── Helpers ────────────────────────────────────────────────────────────

def _make_id() -> str:
    return uuid.uuid4().hex[:12]
